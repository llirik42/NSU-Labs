# Адресное пространство процесса

1) Структура адресного пространства.
    1) Напишите программу, которая создает переменные и выводит их адреса:
        1) локальные в функции;
        2) статические в функции;
        3) константы в функции;
        4) глобальные инициализированные;
        5) глобальные неинициализированные;
        6) глобальные константы.
    2) Сопоставьте адреса переменных с областями адресного пространства из соответствующего /`proc/<pid>/maps`. Объясните увиденное.
    3) Используя утилиту nm (или readelf) определите в каких секциях находятся выделенные переменные переменные.
    4) Напишите функцию, которая создает и инициализирует локальную переменную и возвращает ее адрес. Прокомментируйте результат и дайте оценку происходящему.
    5) Напишите функцию, которая:
        1) выделяет на куче буфер (например, размером 100 байт);
        2) записывает в него какую-либо фразу (например, hello world);
        3) выводит содержимое буфера;
        4) освобождает выделенную память;
        5) снова выводит содержимое буфера;
        6) выделяет еще один буфер;
        7) записывает в них какую-либо фразу (например, hello world);
        8) выводит содержимое буфера;
        9) перемещает указатель на середину буфера;
        10) освобождает память по этому указателю.
        11) выводит содержимое буфера;
    6) Прокомментируйте работу предыдущего пункта.
    7) Заведите переменную окружения.
    8) Добавьте в вашу программу код, который:
        1) распечатывает ее значение;
        2) изменяет его значение;
        3) повторно распечатывает ее значение.
    9) Запустите вашу программу и убедитесь что переменная окружения имеет требуемое значение.
    10) Выведите значение переменной окружения после того как ваша программа завершилась.
    11) Объясните произошедшее.
2) Управление адресным пространством:
    1) Напишите программу, которая:
        1) выводит pid процесса;
        2) ждет одну секунду;
        3) делает exec(2) самой себя;
        4) выводит сообщение “Hello world”
    2) Понаблюдайте за выводом программы и содержимым соответствующего файла `/proc/<pid>/maps`. Объясните происходящее.
    3) Напишите программу, которая:
        1) выводит pid процесса;
        2) ждет 10 секунд (подберите паузу чтобы успеть начать мониторить адресное пространство процесса, например, watch cat `/proc/<pid>/maps`);
        3) напишите функцию, которая будет выделять на стеке массив (например, 4096 байт) и рекурсивно вызывать себя;
        4) понаблюдайте как изменяется адресное пространство процесса (стек);
        5) напишите цикл, в котором на каждой итерации будет выделяться память на куче (подберите размер буфера сами). Используйте секундную паузу между итерациями.
        6) понаблюдайте как изменится адресное пространство процесса (heap);
        7) освободите занятую память.
        8) присоедините к процессу еще один регион адресов размером в 10 страниц (используйте `mmap(2)` с флагом ANONYMOUS).
        9) понаблюдайте за адресным пространством.
        10) измените права доступа к созданному региону и проверьте какая будет реакция, если их нарушить:
            1) запретите читать данные и попробуйте прочитать из региона.
            2) запретите писать и попробуйте записать.
        11) попробуйте перехватить сигнал SIGSEGV.
        12) отсоедините страницы с 4 по 6 в созданном вами регионе.
        13) понаблюдайте за адресным пространством.
    4) Чтобы было удобнее наблюдать за адресным пространством подберите удобные паузы между операциями изменяющими его.
    5) Объясните что происходит с адресным пространством в данной задаче.
3) Самодельная куча
    1) Реализуйте свою кучу над анонимным регионом адресов:
        1) присоедините анонимный регион (`mmap(2)`);
        2) реализуйте функцию my_malloc(), которая:
            1) принимает размер памяти в байтах;
            2) резервирует буфер запрошенного размера и возвращает указатель на его начало;
            3) при недостатке памяти возвращает NULL.
        3) реализуйте функцию my_free(), которая:
            1) принимает указатель на буфер, возвращенный ранее функцией my_malloc();
            2) помечает буфер свободным;
        4) Рекомендация. Для отладки можно присоединить регион связанный с файлом. Это позволит наблюдать за состоянием вашей кучи при выделении-освобождении памяти.