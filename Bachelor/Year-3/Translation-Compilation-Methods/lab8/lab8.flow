import string;

import string;
import lingo/pegcode/driver;
import quotient;

BinaryOp ::= AddOp, SubOp, MulOp, DivOp;
AddOp : ();
SubOp : ();
MulOp : ();
DivOp : ();

Exp ::= Const, Int, Var, Neg, Binary;
Int : (i : int);
Const : (q : Quotient);
Var : (name: string);
Neg : (e: Exp);
Binary : (l : Exp, r : Exp, op : BinaryOp);

// We'll assume that all expressions will be arithmetically correct (for example: there won't be expression "x/0")
// That's why getValue(expression) != nan() is equivalent to the fact that there are no variables in the expression

add(l: Exp, r: Exp) -> Exp {
    Binary(l, r, AddOp());
}

sub(l: Exp, r: Exp) -> Exp {
    Binary(l, r, SubOp());
}

mul(l: Exp, r: Exp) -> Exp {
    Binary(l, r, MulOp());
}

div(l: Exp, r: Exp) -> Exp {
    Binary(l, r, DivOp());
}

simplifiedAdd(l: Exp, r: Exp) -> Exp {
    lValue: Quotient = getValue(l);
    rValue: Quotient = getValue(r);

    if (lValue != nan() && rValue != nan()) {
        Const(addQuotients(lValue, rValue));
    } else if (lValue == zero()) {
        r;
    } else if (rValue == zero()) {
        l;
    } else if (l == Neg(r) || r == Neg(l)) {
        Int(0);
    } else {
        add(l, r);
    }
}

simplifiedSub(l: Exp, r: Exp) -> Exp {
    lValue: Quotient = getValue(l);
    rValue: Quotient = getValue(r);

    if (lValue != nan() && rValue != nan()) {
        Const(subQuotients(lValue, rValue));
    } else if (lValue == zero()) {
        Neg(r);
    } else if (rValue == zero()) {
        l;
    } else if (l == r) {
        Int(0);
    } else {
        sub(l, r);
    }
}

simplifiedMul(l: Exp, r: Exp) -> Exp {
    lValue: Quotient = getValue(l);
    rValue: Quotient = getValue(r);

    if (lValue != nan() && rValue != nan()) {
        Const(mulQuotients(lValue, rValue));
    } else if (lValue == zero() || rValue == zero()) {
        Int(0);
    } else if (rValue == one()) {
        l;
    } else if (lValue == one()) {
        r;
    } else {
        mul(l, r);
    }
}

simplifiedDiv(l: Exp, r: Exp) -> Exp {
    lValue: Quotient = getValue(l);
    rValue: Quotient = getValue(r);

    if (lValue != nan() && rValue != nan()) {
        Const(divQuotients(lValue, rValue));
    } else if (rValue == one()) {
        l;
    } else if (lValue == zero()) {
        Int(0);
    } else {
        div(l, r);
    }
}

simplifiedBinary(l: Exp, r: Exp, op: BinaryOp) -> Exp {
    switch(op) {
        AddOp(): simplifiedAdd(l, r);
        SubOp(): simplifiedSub(l, r);
        MulOp(): simplifiedMul(l, r);
        DivOp(): simplifiedDiv(l, r);
    };
}

simplifiedNeg(e: Exp) -> Exp {
    value: Quotient = getValue(e);

    if (value != nan()) {
        Const(mulQuotients(intQuotient(-1), value));
    } else {
        Neg(e);
    }
}

simplify(e: Exp) -> Exp {
    switch(e) {
        Neg(e1): simplifiedNeg(e1);
        Binary(l, r, op): {
            ls: Exp = simplify(l);
            rs: Exp = simplify(r);
            simplifiedBinary(ls, rs, op);
        }
        default: e;
    }
}

buildSub(xs : [flow]) {
    fold(xs[1], xs[0], \acc, x -> Binary(acc, x, SubOp()))
}

buildDiv(xs : [flow]) {
    fold(xs[1], xs[0], \acc, x -> Binary(acc, x, DivOp()))
}

getRepr(e: Exp) -> string {
    switch(e) {
        Int(i): i2s(i);
        Const(q): getQuotientRepr(q);
        Var(name): name;
        Neg(e1): "-" + getRepr(e1);
        Binary(l, r, op): {
            lRepr: string = getRepr(l);
            rRepr: string = getRepr(r);
            "(" + switch(op) {
                AddOp(): lRepr + " + " + rRepr;
                SubOp(): lRepr + " - " + rRepr;
                MulOp(): lRepr + " * " + rRepr;
                DivOp(): lRepr + " / " + rRepr;
            } + ")";
        }
    }
}

getValue(e: Exp) -> Quotient {
    switch(e) {
        Int(i): intQuotient(i);
        Const(q): q;
        Var(name): nan();
        Neg(e1): mulQuotients(intQuotient(-1), getValue(e1));
        Binary(l, r, op): {
            lValue: Quotient = getValue(l);
            rValue: Quotient = getValue(r);
            switch(op) {
                AddOp(): addQuotients(lValue, rValue);
                SubOp(): subQuotients(lValue, rValue);
                MulOp(): mulQuotients(lValue, rValue);
                DivOp(): divQuotients(lValue, rValue);
            };
        }
    }
}

derive(e: Exp, varName: string) -> Exp {
    switch(e) {
        Var(name): if(name == varName) Int(1) else Int(0);
        Neg(e1): Neg(derive(e1, varName));
        Binary(l, r, op): {
            ld: Exp = derive(l, varName);
            rd: Exp = derive(r, varName);
            switch(op) {
                AddOp(): simplifiedAdd(ld, rd);
                SubOp(): simplifiedSub(ld, rd);
                MulOp(): simplifiedAdd(simplifiedMul(l, rd), simplifiedMul(ld, r));
                DivOp(): simplifiedDiv(simplifiedSub(simplifiedMul(ld, r), simplifiedMul(l, rd)), simplifiedMul(r, r));
            };
        }
        default: Int(0);
    }
}

grammar = compilePegGrammar("#include lingo/lab8.lingo");
specialPegActions = {
    t1 = setTree(defaultPegActions.t, "buildSub", buildSub);
    t2 = setTree(t1, "buildDiv", buildDiv);
    SemanticActions(t2);
}

main() {
    str: string = " x / (x+1) + (x+2)/(x+3) + y";
    expression: Exp = parsic(grammar, str, specialPegActions);
    d: Exp = derive(expression, "x");
    println(getRepr(d));
    quit(0);
}
