# Задачи на работу с потоками

## Блок задач на «удовлетворительно»

1. [Создание потоков посредством POSIX API](3/1)
	1. Склонируйте репозиторий `git@github.com:mrutman/os.git`. Изучите и запустите программу `threads/thread.c`. Добейтесь чтобы гарантированно выполнялись оба потока.
	2. Измените программу, добавив создание 5-ти потоков с одинаковой поточной функцией.
	3. В поточной функции распечатайте:
		1. идентификаторы процесса, родительского процесса, потока. Для получения идентификатора потока используйте функции `pthread_self()` и `gettid()`. Сравните с тем что функция `pthread_create()` вернула через первый аргумент. Объясните результат. Почему для сравнения идентификаторов POSIX потоков надо использовать функцию `pthread_equal()`?
		2. адреса локальной, локальной статической, локальной константной и глобальной переменных. Объясните результат.
	4. В поточной функции попробуйте изменить локальную и глобальную переменные. Видны ли изменения из других потоков? Объясните результат.
	5. Изучите `/proc/pid/maps` для полученного процесса. Найдите в нем стеки потоков.
	6. Запустите программу из-под strace. Найдите системные вызовы, которые создали ваши потоки.
2. [Потоки `Joinable` и `Detached`](3/2)
	1. Напишите программу, в которой основной поток будет дожидаться завершения созданного потока.
	2. Измените программу так чтобы созданный поток возвращал число `42`, а основной поток получал это число и распечатывал.
	3. Измените программу так чтобы созданный поток возвращал указатель на строку `"hello world"`, а основной поток получал этот указатель и распечатывал строку.
	4. Напишите программу, которая в бесконечном цикле будет создавать поток, с поточной функцией, которая выводит на свой идентификатор потока и завершается. Запустите. Объясните результат.
	5. Добавьте вызов `pthread_detach()` в поточную функцию. Объясните результат.
	6. Вместо вызова `pthread_detach()` передайте в `pthread_create()` аргументы, задающие тип потока — `DETACHED`. Запустите, убедитесь что поведение не изменилось.
3. [Передача параметров в поточную функцию](3/3)
	1. Создайте структуру с полями типа `int` и `char*`. Создайте экземпляр, этой структуры и проинициализируйте. Создайте поток и передайте указатель на эту структуру в качестве параметра. В поточной функции распечатайте содержимое структуры.
	2. Измените программу так чтобы поток создавался как `detached` поток. Объясните в какой области памяти нужно располагать структуру в этом случае.
4. [Прерывание потока](3/4)
	1. Напишите программу, в которой поточная функция в бесконечном цикле распечатывает строки. Используйте `pthread_cancel()` для того чтобы ее остановить.
	2. Измените программу так чтобы поточная функция ничего не распечатывала, а в бесконечном цикле увеличивала счетчик на 1. Используйте `pthread_cancel()` для того чтобы ее остановить. Объясните результат. Что можно сделать, чтобы `pthread_cancel()` прервал поток?
	3. В поточной функции выделите память под строку `"hello world"` с помощью `malloc()`. Распечатывайте в бесконечном цикле полученную строку. Используйте `pthread_cancel()` для того чтобы прервать поточную функцию. Добейтесь чтобы по завершению память, выделенная под строку освобождалась. Используйте `pthread_cleanup_push/pop()`.
5. [Обработка сигналов в многопоточной программе](3/5)
	1. Напишите программу с тремя потоками, такими что: первый поток блокирует получения всех сигналов, второй принимает сигнал `SIGINT` при помощи обработчика сигнала, а третий — сигнал `SIGQUIT` при помощи функции `sigwait()`.
	2. Можно ли установить обработчики сигнала для каждого потока?

## Блок задач на «хорошо»

[Разработать](https://github.com/llirik42/Kernel-Thread) собственную функцию для создания ядерных потоков — аналог `pthread_create()`:

```C
int mythread_create(mythread_t thread, void *(start_routine), void *arg);
```

Функция должна возвращать успех-неуспех.

## Блок задач на «отлично»

[Разработать](https://github.com/llirik42/User-Thread) собственную функцию для создания пользовательских потоков:

```C
int uthread_create(uthread_t thread, void *(start_routine), void *arg);
```

Функция должна возвращать успех-неуспех. Допускается реализация без вытеснения потока.
