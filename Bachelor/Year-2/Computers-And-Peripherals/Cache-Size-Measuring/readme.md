# Измерение размера кэш-памяти

## Задание

1. Написать программу, многократно выполняющую обход массива заданного размера тремя способами (прямой, обратный и случайный). 
2. Для каждого размера массива и способа обхода измерить среднее время доступа к одному элементу (в тактах процессора). Построить графики зависимости среднего времени доступа от размера массива. Каждый последующий размер массива отличается от предыдущего не более, чем в 1,2 раза.
3. Определить размеры кэш-памяти точным образом (на основе документации по процессору используемой машины; утилите, отражающей характеристики процессора; системному файлу; …).
4. На основе анализа полученных графиков:
	* оценить размеры кэш-памяти различных уровней (обосновать ответ) 
	* сопоставить результат с известными реальными значениями
	* определить размеры массива, при которых время доступа к элементу 
	* массива при случайном обходе больше, чем при прямом или обратном 
	* объяснить причины этой разницы во временах
5. Составить отчет по лабораторной работе. Отчет должен содержать 
следующее:
	* описание алгоритмов заполнения массива тремя способами (особенно — случайным)
	* график и таблицу зависимости среднего времени доступа к одному элементу от размера массива и способов обхода
	* полный компилируемый листинг реализованной программы и команду для ее компиляции
	* вывод по результатам лабораторной работы

## Примечания
1. Обход может быть выполнен циклом следующего вида:
	```C
	for (k=0, i=0; i<N*K; i++) k = x[k];
	```
2. Компилировать программу нужно с ключом оптимизации `-O1` чтобы исключить лишние обращения в память за счёт размещения переменных на регистрах.
3. Перед измерением времени для каждого размера $N$ необходимо осуществить однократный обход массива, чтобы «прогреть кэшпамять», то есть выгрузить из кэш-памяти посторонние данные, разместив там (по возможности) необходимые нам данные.
4. В начале программы перед началом счёта и измерения времени нужно около 1 секунды погонять пустой цикл с каким-нибудь расчётом (например, умножение матриц), чтобы процессор с динамически изменяемой частотой установил её на фиксированном уровне. Иначе в начале замеряемого промежутка времени процессор будет работать на пониженной частоте, и значения на графике будут чуть выше.
5. Поскольку будут применены оптимизации, компилятор может выкинуть весь цикл как ненужный. Чтобы он этого не делал, нужно после завершения замера времени изобразить "использование" полученного в цикле значения, например, так:
	```C
	if (k == 12345) printf("Wow!");
	```
	Также следует поступить после "холостых" вычислений для выхода процессора на максимальную частоту и после прогрева кэша.
6. Поскольку нам нужно именно время в тактах, то удобнее сразу применить таймер `rdtsc`, возвращающий именно число тактов.
7. Для случайного обхода необходимо формировать массив таким образом, чтобы цикл был один и его длина равнялась длине массива.

## Пример использование таймера rdtsc

```C
#include <stdio.h> // for printf

union ticks{
	unsigned long long t64;
	struct s32 { long th, tl; } t32;
} start, end;

int main(){
	asm("rdtsc\n":"=a"(start.t32.th),"=d"(start.t32.tl));
 
	// some work
 
	asm("rdtsc\n":"=a"(end.t32.th),"=d"(end.t32.tl));

	printf("Tacts taken: %lf \n",(end.t64-start.t64));
	
	return 0;
}
```
