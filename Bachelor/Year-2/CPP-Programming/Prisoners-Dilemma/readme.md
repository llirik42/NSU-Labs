# Дилемма заключённого

## Задание

Реализовать консольное приложение, позволяющее симулировать повторяющуюся "Дилемму заключённого" для троих заключённых.

## Устройство игры

Программа позволяет "соревноваться" трём "заключённым" (далее — стратегиям), которые пытаются максимизировать набранные очки. Выигрывает стратегия, по результатам игры (некоторого фиксированного количества ходов) набравшая наибольшее количество очков.

Игра протекает следующим образом: пошагово, в течение некоторого количества шагов, симулятор выясняет выбор каждой стратегии: сотрудничать (C) или предать (D). После этого, симулятор сообщает каждой стратегии выбор её оппонентов и вычисляет очки за текущий раунд. Очки вычисляются по матрице игры.

Стратегии делают свой выбор основываясь на накопленном опыте: истории ходов оппонентов и собственной. Алгоритмы стратегий могут быть самыми различными, начиная от тривиальных "всегда сотрудничать" или "выдавать случайный результат". Изначально, история ходов каждой стратегии пуста.

Симуляция может проходить в трёх режимах:
1. **Соревнование с детализацией**. На каждом шаге программа ожидает нажатия клавиши от пользователя, после которого делает один шаг. Подробное состояние симуляции выводится после каждого шага (выбор каждой стратегии, очки за текущий ход, очки за текущую игру). Игра прерывается по команде `quit`.
2. **Соревнование без детализации**. Программа вычисляет заданное количество ходов и выводит результат.
3. **Турнир**. Программа перебирает все возможные тройки (без повторений, т.е. ($s_1$, $s_2$, $s_3$) и ($s_3$, $s_2$, $s_1$) — одна и та же тройка) указанных стратегий и по общему результату выявляет победителя по сумме баллов за все игры. Результаты каждого соревнования и итоговый протокол выводятся на экран.

## Технические подробности

1. На старте программе подаются следующие аргументы командной строки:
	- три (или более — для турнирного режима) имени соревнующихся стратегий
	- название режима `--mode=[detailed|fast|tournament]` (опциональный, по умолчанию — `detailed` для трех стратегий, `tournament` для > 3 стратегий)
	- число шагов симуляции `--steps=<n>` (опциональный)
	- директория с конфигурационными файлами стратегий `--configs=<dirname>` (опциональный)
	- файл с матрицей игры `--matrix=<filename>` (опциональный)
2. Каждая стратегия представляется в виде класса. У стратегий выделяется общий абстрактный интерфейс. Нетривиальные стратегии хранят свои параметры в собственном конфигурационном файле произвольного формата. 
3. Для конструирования классов-стратегий следует использовать шаблон проектирования "Фабрика объектов".
4. Матрица игры описывает количество очков, получаемых стратегиями за каждый ход. Матрицу по умолчанию можно вшить в код программы. Пример правильной матрицы для игры с тремя заключёнными содержится в приложении. Формат файла с матрицей произволен.
5. При реализации программы подразумевается максимальное использование *STL*. Для работы с файлами необходимо использовать файловые потоки, переключенные в режим сообщения об ошибках исключениями (см. метод `std::ios::exceptions`).

## Формат файла с матрицей

Построчно, в каждой строке 3 буквы, разделенные пробелами, и 3 целых числа, разделенные пробелами. Буквы — это описание исхода (ответов стратегии 1, 2, 3), а числа — это очки, которые получили стратегии 1, 2, 3 при таком исходе. Пример:

	С  С  С  7  7  7
	C  C  D  3  3  9
	C  D  C  3  9  3
	D  C  C  9  3  3
	C  D  D  0  5  5
	D  C  D  5  0  5
	D  D  C  5  5  0
	D  D  D  1  1  1

В матрице ровно 8 строк, числа одинаковы с точностью до перестановок столбцов исходов и столбцов очков. Если это условие нарушается (например, для матрицы выше будет строка "D C C" с очками, не равными 9 3 3), выводится сообщение об ошибке и программа закрывается.

## Требования

1. Билд на *CMake*.
2. Дополнительные библиотеки (типа *Qt*) не использовать, только *STL* и *GoogleTest*.
3. Можно воспользоваться библиотекой для разбора параметров командной строки (любой, на ваш выбор). Но в этом случае вы должны обеспечить беспроблемную сборку через *CMake* без предвратиельного скачивания библиотеки (т.е. чтобы *CMake* качал сам, как это сделано для *GoogleTest*).
4. Безопасная с точки зрения исключений реализация.
5. Реализовано 3 "простых" стратегии, то есть таких, которые не используют результаты предыдущих раундов для своего ответа (стратегии "всегда сотрудничает" и "всегда предает" — это, по сути, одна стратегия с параметром, поэтому считается за одну, а не за две).
6. Реализованы 2 "сложных" стратегии, то есть такие, которые использует данные предыдущих раундов для ответа.
7. Реализованы режимы **Соревнование с детализацией** и **Соревнование без детализации**.
8. Стратегии реализуют единый интерфейс и не зависят от остального кода.
9. Для конструирования стратегий используется паттерн "фабричный метод".
10. Реализован параметр командной строки `--help`, выводящий справку о программе, аргументах командной строки и список доступных стратегий.
11. Проверка матрицы на консистентность. Должны соблюдаться неравенства $D > C > d > c$, $2C > D + c$.
12. Работа с матрицей (чтение из файла, проверка на консистентность и т.д.) — в отдельном классе.
13. Чистый понятный код, консистентный (везде одинаковый) стиль кодирования, хорошее оформление.

## Дополнительные требования

1. Тесты на *GoogleTest*.
2. Реализован режим **Турнир**.
3. Реализовано минимум 3 "сложных" стратегии.
4. Минимум 1 сложная стратегия сохраняет состояние между запусками программы (на диске в папке, обозначенное параметром командной строки `--configs`).
5. Стратегии хранят своё состояние не напрямую, через переданный им объект абстрактного интерфейса `Storage`. Сделано 2 конкретных реализации `Storage`: 
	1. чисто в памяти
	2. на диске  
	Если программа запущена с параметром `--configs`, используется хранение данных на диске (в этой папке), иначе — в памяти. Этот пункт исключает пункт 4, т.к. в этом случае конкретный способ хранения состояния игровых стратегий определяется не самой стратегией, а вызывающим её кодом.
6. Реализовано минимум 5 "простых" стратегий.
7. Реализованы одна или несколько "метастратегий" (использующие несколько других стратегий для принятия решения).
8. Сборка стратегий в отдельную библиотеку, динамическая линковка стратегий.
9. Поддержка комментариев в файле матрицы, поддержка произвольного количества пробельных символов между элементами строки матрицы в файле.
