# Упрощенный парсер CSV

## Subtask #1 — print tuple

Используя рекурсивные шаблоны реализовать оператор для печати `std:tuple`:

```C
auto operator<<(std::basic_ostream<Ch, Tr>& os, std::tuple<Args...> const& t)
```

## Subtask #2 — simple CSV parser

### CSV format

Табличные данные могут быть представлены как текстовый файл с разделителем '\n' между строками и символом ','' для разделения ячеек внутри строки. Считаем что данные символы не встречаются внутри данных.

### CSVParser

#### Задание

Написать класс делающий возможным следующую потоковую работу с *CSV*:

```C
int main()
{
	ifstream file("test.csv");
	CSVParser<int, string> parser(file, 0 /*skip first lines count*/);
	for (tuple<int, string> rs : parser) {
		cout<<rs<<endl;
	}
}
```

Потоковая обработка подразумевает lazy (ленивое) чтение строк. Таким образом необходимо реализовать http://en.cppreference.com/w/cpp/concept/InputIterator для чтения данных в *CSV* файле.

#### Требования

1. Все итераторы константные
1. Нельзя читать весь файл сразу
3. Чтение происходит по 1 строке в двух местах: при создании итератора и при его инкременте. Оператор `*` у итератора не читает, а только возвращает ранее прочитанный кортеж. Еще чтение возможно для скипа первых *N* строк в конструкторе, если пользователь это запросил
4. Независимые итераторы. То есть, чтобы можно было получить несколько итераторов с помощью `begin()` от одного парсера и работать с ними независимо. Для упрощения этой задачи разрешается поменять конструктор парсера — в условии задачи он принимает `ifstream`, вы можете сделать, чтобы он принимал путь до файла. Разрешается на каждый итератор открывать файл заново. Также можно работать с файлом в бинарном режиме

#### Дополнительные требования

1. Поддержка заголовка *CSV*. В первой строке могут быть названия колонок, а данные — со второй строки. Вы эти название отдельно читаете в строки и даете возможность их отдельно получить
2. Поддержка экранирования данных
3. Конфигурация парсера: что считать разделителем между строками и колонками и что за символ использовать для экранирования (по умолчанию двойные кавычки)
4. Обработка ошибок: выкидывать исключение с информаций о месте в файле (строка, колонка) где произошла ошибка разбора данных
5. Итераторы обратного обхода (методы `rbegin()`, `rend()`, читать с конца файла в начало)
6. Не константные итераторы (то есть, возможность изменения *CSV*-файла через итератор)
